
20151111

微服务和Docker为什么重要呢？因为今天在云的世界里竞争是非常激烈，优胜劣汰。那些为应用程序开发者提供简单、快速、伸缩和灵活性的工具成功了，而其他的工具失败了。Docker做的事情就是缩短了构建、测试和部署的周期，并且提供了一种分离方式，通过微服务来分离基础设施、平台和应用程序团队的功能。
20150923
docker现在支持windows通过 oracle VirtualBox(原来sun的) 现在直接用hyper-v了
Kitematic, the Docker GUI, runs on Mac OS X and Windows operating systems
Docker Machine is supported on Windows, OS X, and Linux operating systems.
 Docker Swarm to host and schedule a cluster of Docker containers.
1.8 安装 运行
关闭firewalld 
systemctl stop  firewalld.service
 systemctl enable docker
systemctl start docker 
systemctl stop docker

systemctl restart docker
docker dameon 在centos 7下面的 配置文件需要手工创建在  /etc/systemd/system/docker.service.d/docker.conf 
查看 docker dameon的日志
journalctl -u docker
1.8 代理设置
sudo HTTP_PROXY=http://192.168.8.26:8080/ docker -d &
 

如果你的做好了所有代码，想分发给你的使用者，这种无疑代码放到image是最佳的，包括你的数据库初始化脚本等。例如wordpress .

如果你是开发环境，代码是用于调试，代码是不应该在image里面的，利用dockerfile，自动git pull也不是好的方案，当然更不提倡ssh到容器，去修改代码

建议用 Dockerfile build 镜像，镜像文档化
Swarm 目前使用较多
最小化镜像大小，分层设计，尽量复用
一容器一进程，便于服务监控与资源隔离
如果有高性能需求，并且你的container是跑在物理机上的，建议使用 local volume + host dev 方案；


容器的网络模式

host模式： 容器和宿主机共享Network namespace。
container模式： 容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。
none模式： 容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。
bridge模式： Bridge模式是Docker的默认模式，下面这张图即为Bridge模式下Docker容器的网络连接图。 其实就是NAT

embedded DNS server reachable at 127.0.0.11 will be listed in the container’s resolv.conf 

overlay : 容器间通信用 基于 VxLan
macvlan/ipvlan:容器间通信用，也可以用于容器直接对外提供服务

Swarm将每一个主机上的docker-egnine管理起来，对外提供容器集群服务。最上面是Compose项目，Compose项目主要用来提供基于容器的应用的编排。用户通过yml文件描述由多个容器组成的应用，然后由Compose解析yml，调用Docker API，在Swarm集群上创建出对应的容器。
一般是要求 
容器无状态，容器中不要留中间数据
360的使用经验
容器内部绑定独立IP。
容器内部开启多进程服务。
自动添加监控。
CPU配额硬限制。
容器绑定独立IP这样外部可直接SSH了。
Run only one process per container
持续集成当然是Docker最纯粹的玩法了，通过『Dockerfile-构建镜像-创建新容器』来完成环境的变更


mesosphere=marathon+mesos+Chronos 用来部署docker 
或者用Kubernetes  
Mesos是C++

2006年， 谷歌第一次对外介绍容器化组件cgroups和namespaces，可以说这是现代Linux容器的开端
Twitter，几乎完全是在Mesos上面运行的
Apache Mesos从研究论文开始，2010年成为Apache孵化项目，后来从ASF“毕业”，并于2013年建立商业实体Mesosphere。


Docker可以使用COW（copy-on-write）文件系统来缓存Dockerfile指令， 类似于LVM的快照，
到现在仍然仅仅支持满是问题的AuFS（AnotherUnionFS）。
支持下面的存储方式(支持层级的文件系统 union在一起）
AuFS最稳定，最早
Devicemapper redhat/centos 专用
overlayfs      新一代，快，稳定
btrfs 不太稳定
ZFS 也不太稳定 


代码是用于调试，代码是不应该在image里面的，用volume挂载合适
如果你的做好了所有代码，想分发给你的使用者，这种无疑代码放到image是最佳的
老服务，不想大改造，一个就一个呗。有精力能重构，拆分成适合Docker的一个服务一个镜像为好。一步步来，把需要能剥离的先做
。随着自己水平的提高和Docker自身的发展，选择可以不一样。 
对于应用架构而言，Docker希望应用尽量无状态、可重新部署、可水平扩展，如果应用比较传统可能需要调整。
对于运维来说，监控采集的指标可能会发生一些变化，不能把传统的针对OS和虚机的监控简单迁移到Docker来，
需要针对其数量和生命周期进行相应的调整。

应用场景：打包发布程序，动态升级，生产回滚等等
目前对Docker的使用分为两大类，你要么把容器当系统中的一个进程，要么会把容器当一台虚拟机来使用。


docker 运行直接共享host的kernel，而kvm需要独立的kernel
docker 支持运行的时候设置cgroup信息比如  -c, --cpu-shares Set the cpu priority for the container.  -m, --memory Set the maximum amount of memory the container can
use, specify units with b, k, m or g.

也可以用virsh来做lxc的container 
每个 LXC "容器" 之间或许不兼容，但是 docker 采用了一种标准的配置方法使得由不同 docker 创建出的 LXC 能够完全兼容。
LXC 的定位是作为一种虚拟机的替代方案。虽然所有的软件都可以安装在由 LXC 或者 docker 管理的容器中， 但是 docker 更倾向于在一个容器中运行一个应用。


要在虚拟机上执行命令，可以通过  docker inspect -f {{.State.Pid}} container_id 先获取进程号，然后
 nsenter 来运行 比如  nsenter -m -u -n -i -p -t 进程号 命令来执行
 
安装 
禁用 SELINUX
/etc/selinux/config
SELINUX=disabled 
SELINUXTYPE=targeted

  yum install docker  
  
redhat使用  device mapper thin provisioning plus this loopback mounted device  代替AUFS 
docker使用如下顺序的unionfs
// Slice of drivers that should be used in an order
 priority = []string{
 "aufs",
 "btrfs",
 "devicemapper",
 "vfs",
 "overlayfs",
 
运行
docker -d & 或者指定端口运行 docker -H 0.0.0.0:5555 -d & or docker -H   tcp://[host][:port]` or `unix://path
查看版本
docker version
 
export HTTP_PROXY=http://192.168.8.26:8080 设置后需要重启 docker 

 然后重启  docker 

下载image 
在hub注册
https://hub.docker.com/
然后 docker login

image放在 /var/lib/docker 

查看container 
docker ps  only live的 或者 docker ps -a 全部的包括已经停止的
关闭 
docker stop stupefied_albattani
获取log
docker logs name 

运行container 
docker run -t -i centos:7 /bin/bash

-t flag assigns a pseudo-tty or terminal inside our new container and the -i flag allows us to make an interactive connection by grabbing the standard in (STDIN) of the container
-P flag was used to automatically map any network ports inside it to a random high port from the range 49153 to 65535 on our Docker host
docker ps -l
指定端口 运行 -p 127.0.0.1:5000:5000  -p  5000:5000   -p 127.0.0.1::5000(任意Local host的可用端口) -p 127.0.0.1:5000:5000/udp 
docker run -d -p 5000:5000 training/webapp python app.py
查看log 
docker logs -f nostalgic_morse
查看container的top trade
docker top nostalgic_morse
查看container信息
docker inspect nostalgic_morse
查看container的port map
docker port evil_pasteur  5000  

根据container 创建新的image 
ocker commit -m="Added txt" -a="Roger" f89f833aa7c1 centos/roger
给image打tag
docker tag 4a7c282f5a9d centos/roger:v2 打完之后出现一个新的 image 
删除 image
docker rmi centos/roger
删除container 
docker rm test1
link container alias和别名会自动push 到 hosts
docker run -t -i --name test2 --link db:db centos:7 /bin/bash
volume共享 两边就能同时共享了 会在container上面mount这个目录 只读 -v /src/webapp:/opt/webapp:ro
文件基本的共享  -v ~/.bash_history:/.bash_history
docker run -d -P --name web -v /webapp:/test training/webapp python app.py

docker run --rm -v /foo -v awesome:/bar busybox top
This command creates an anonymous /foo volume. When the container is removed, the Docker Engine removes the /foo volume but not the awesome volume.

attach 到container ,用 ctrl+p 然后 ctrl+q退出
docker attach container2

attach 网络到 container 
docker network connect my-bridge-network web
docker network disconnect my-bridge-network web

创建network    
docker network create -d bridge --subnet 172.25.0.0/16 isolated_nw
docker network create -d host    --subnet 10.163.1.11/24 --gateway 10.163.89.1  host_nw
docker network create -d macvlan    --subnet=10.163.89.11/24    --gateway=10.163.89.1     -o parent=eno16777984 pub_net

bridge 模式下，缺省能联通外网 ，通过host主机联通 做了 post nat  MASQUERADE

启动的时候关联network
docker run --network=pub_net --ip=10.163.89.16 -itd --name=container6 busybox

通过datavolume container 共享


docker run -t -i --name test2 -v /root/:/test centos:7 /bin/bash
docker run -t -i --name test1 --volumes-from test2 centos:7 /bin/bash 这样 test1/test2里面会有个/test 和host的 /root一样

备份一个container里面的一个mount的volume 内容到 host的当前目录
docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
从container copy 到host 
docker cp test_container:/etc/hosts .
导出 container 到 file  docker export container_name 导入  docker import source
导出 image docker save --output=file_name image_name  导入 docker load --input=archive

导出 image 
docker save mynewimage > /tmp/mynewimage.tar
导入image 
docker load < /tmp/mynewimage.tar
 
build一个新的image  
多使用copy 少使用 add 
CMD 代表container起来需要运行的命令
也可以通过 ENTRYPOINT 指定，然后在 run container 的时候指定运行参数

ENTRYPOINT ["nginx"]  指定缺省命令
CMD ["--help"]              指定缺省参数

Dockerfile 

FROM        ubuntu:trusty
RUN         apt-get update && apt-get install -y redis-server
EXPOSE      6379
ENTRYPOINT  ["/usr/bin/redis-server"]

docker build -t <your username>/redis .


Dockerfile  
FROM centos
MAINTAINER Roger <SvenDowideit@docker.com>

RUN yum -y install openssh-server;yum clean all
RUN mkdir /var/run/sshd
RUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key
RUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key
RUN /bin/echo 'root:123456'|chpasswd
COPY  wzy.txt /home
RUN /bin/sed -i 's/.*session.*required.*pam_loginuid.so.*/session optional pam_loginuid.so/g' /etc/pam.d/sshd
RUN /bin/echo -e "LANG=\"en_US.UTF-8\"" > /etc/default/local
EXPOSE 22
CMD ["/usr/sbin/sshd", "-D"]


配置veth pair
ip netns add ns1
ip netns add ns2

brctl addbr br-test
brctl stp br-test off
ip link set dev  br-test up

ip addr add 10.0.2.1/8 dev  br-test

#for ns1
ip link add tap1 type veth peer name br-tap1
brctl addif br-test br-tap1
ip link set tap1 netns ns1
ip netns exec ns1 ip link set dev tap1 up
ip link set dev br-tap1 up
ip addr add 10.0.2.2/8 dev tap1
#lo起来之后才能ping通本地的地址
ip link set lo up   
#for ns2
ip link add tap2 type veth peer name br-tap2
brctl addif br-test br-tap2
ip link set tap2 netns ns2
ip netns exec ns2 ip link set dev tap2 up
ip link set dev br-tap2 up
ip addr add 10.0.2.3/8 dev tap2
ip link set lo up

这样两个ns就能ping通了，firewalld关闭也能通
联通外网
ip netns exec ns1 route add default gw 10.0.2.1 tap1
#必须放到通外网的网卡上 或者不加网卡
iptables -t nat -I POSTROUTING -s 10.0.2.0/24 -o team0 -j MASQUERADE  

监控 ping 
tcpdump -e -i any -p icmp  and   host 192.168.193.176 

7万多
